1. 为什么要设计这个框架？
   因为传统的框架分依赖很多中间件，中间件的不稳定会导致不可用，同时其它中间件部署维护都需要成本。
   分而治之的架构，也不是完全绝对的，会给开发人员大量的学习、维护成本。
4. 设计思想？
   就是要用牛逼的架构算法替代中间件，MapReduce的思想，去中心化思想，约定规则优先（约定好的性能大于去通过网络做共识）
   根据实际的场景来设计，优先支持二八定律中80%的场景。
2. 为什么不多依赖一些功能包？
   依赖太多包会导致框架重量级，同时可能会跟使用者依赖的包产生各种冲突，不利于使用者使用。
   如果一个框架的学习成本大于框架的开发成本，那还不如自研一个。
3. 依赖包都有什么？为什么用这些？
   FastJSON 打日志转用，配合idea或其它格式化工具，能极大的提高排查问题的效率。
   Netty    执行机之间通讯使用。即用到了NIO，也避免NIO的一些坑。
   Protobuf 考虑到执行机的暴增可能会对网络造成压力，使用Protobuf算法来压缩报文体积，节省带宽。
   quartz   定时调度器，cron表达式更强大，灵活


要提供哪些功能？

功能支持列表：
1. 提供控制台（内嵌还是独立一个出来待细考虑，第一版先内嵌）
2. 提供暴露各种维护接口，供使用方扩展（比如使用方要能过第三方程序来调用，或使用自己的展示工具来展示）
3. 配置工作流，并行或串行执行
4. 手动调整参数，如任务分配，分片参数，线程数，pageSize, chunkSize等
5. 自动调整参数，根据历次执行的资源利用率，计算出本次需要的结果（智能调优，当然这是初步调优，在业务代码不调优的前提下做到资源利用最大化）
6. 手动执行、自动执行
7. 批量元数据持久化，支持DB和非DB，非DB模式下将持久化到每个执行机，各一份。

难点有哪些？
  1. 适应各种批量场景。
    有些场景需要一台执行机执行，就涉及到选举单节点执行。
    不同的场景有：
    数据库->数据库
    数据库->调接口
    数据库->文件
    文件->数据库
    文件->文件
    ....
    总之所有场景就是 数据库、文件、网络接口三者的排列组合。
    要支持这么多场景。
  2. 故障转移
    一台有故障如何转移，这涉及到状态的复制等
  3. 重跑续跑支持

  4. 资源留buffer，确保sdk线程不死

测试场景
3台执行机，一个库
                                          |-->生成账单文件->合并->上传FTP
任务：FTP下载->吃清算文件->拆分->入账->记息账单->|
                                          |-->生成交易文件->合并->上传FTP

公共组件组成自己需求的东西，数据结构算法直接实现。


第一个版本1.0限制条件：
不支持多进程，只支持一个IP一个进程
不支持多数据源

TODO:
参数下传，传下一个TASK，参数作用域
IOC父类属性注入




目录介绍


核心实现：
0. 基础设施
IOC、DB、通讯、日志
DB:
  hashTable,二叉树

1. 任务流图的遍历，图数据加载与遍历执行
链表无法实现循环，即下面的任务执行完再跳到上面的任务执行。
任务流图本质是一个有向图，所以最好后面用邻接矩阵实现。

2. IOC

3. 数据持久化

4. 共识机制

5. 分片调整计算

6. 任务遍历执行